---
title: "20210511 TypeSciprt 06,  " #제목
category: #카테고리
tag: #태그
  - TypeScirpt
toc: true #옆에 목차
---

# TypeScript06

<p align="center">
<img src="../assets/img/TS_logo.png" width="400px" height="400px">
</p>

> # Class

## 클래스?

- ojbect를 만드는 blueprint (설계도)
- 클래스 이전에 object를 만드는 기본적인 방법은 function
- JS는 es6 부터 class를 사용 가능 (접근 제한 키워드가 부족함)
- OPP을 위한 초석
- TypeScript 에서는 클래스도 사용자가 만드는 타입의 하나임 (JS보다 강력한 class 기능)

<br>

> ## class 선언과 사용

### class 선언&사용 : 기본 방법

- class 키워드 사용
- class 이름은 대문자
- new 키워드를 이용하여 class를 통해 object를 생성할 수 있음
- 기본 property에 값을 할당하여 class를 만들고 object를 생성하면 기본 property가 초기값으로 설정되어 object가 만들어짐

```js
class Per {
  name: string = "kim";
}
const per = new Per();
```

<br>

### class 선언&사용 : 생성자를 이용한 방법

- constructor 키워드를 사용해서 나중에 property에 값을 무조건 넣게 지정할수 있다. (일단은, class 안에서 값 자체가 할당 안되어 있어도 compile error가 없음)
- this 키워드를 사용해서 class에 있는 property를 class 내부에서 사용할 수 있음
- object 생성시 class 안에 constructor를 이용하여 object를 생성하면서 값을 전달할 수 있다.

```js
class Person0 {
  name; // property

  constructor(name: string) {
    this.name = name;
  }
}
```

<br>

> ## contructor & initialize

- strict 모드 옵션이 켜져있고 constructor가 없는 class의 property는 반드시 초기화를 시켜주어야 함으로 class 내부적으로 값을 할당 해주어야 한다. (초기화를 검사하는 옵션 : `strictPropertyInitialization`)
- 만약, 내부적으로 값 할당 안하고 나중에 외부에서 값을 할당해 준다고 하더라도 compile error는 발생함 (class는 불완전하게 느끼고 runtime까지 고려 못함)
  - 예) age는 number이지만 할당 되지 않으면 나중에 값을 불러올때 undefined 가 됨으로
- 만약 초기값을 할당 안하고 나중에 개발자가 신경써서 한다는 것을 `!`을 사용해서 표시하고 compile error를 일단은 벗어날수 있다.

```js
class Person1 {
	name: string = 'Jerry';
	// age: number; // error 발생
  age!: number; // ! 사용할땐 주의하자 나중에 값할당 안하면 온전히 개발자 잘못이므로
}

const p1: Person1 = new Person1();
console.log(p1);
console.log(p1.age); // undefined 뜨게 됨 (type은 number라고 뜨지만)
p1.age = 2; // runtime 보완 해도 고려 안됨 (!를 사용 안하면)
console.log(p1.age); // ok (위에서 2로 할당 시켜 줬기 때문에)
```

### 초기화 할때 값을 할당하거나 안하고 싶은 경우 (type 안정성 유지)

- constructor 에서 매개변수에 `?`을 붙여 optional로 만든다.
- 하지만, type은 안정화 시켜줘야 하기 때문에 contructor 안에 if 문을 통해서 undefined 시 해당 type의 기본 값을 할당하게 하여 어쨌거나 해당 type을 만족하도록 한다.

```js
class Person2 {
  name: string = "Tom";
  age: number;

  constructor(age?: number) {
    if (age === undefined) {
      this.age = 1;
    } else {
      this.age = age;
    }
  }
}
const p2: Person2 = new Person2(); // OK
const p2_1: Person2 = new Person2(24); // OK
```

<br>

### 비동기적으로 초기화 하고 싶은 경우

- contructor 키워드에는 async를 붙일 수 없음
- 초기화 할수 있는 메서드를 만들어서 활용해야 함 (async 가능)
- class의 메서드를 통해서 값을 할당을 통해 초기화 한다고 해도 class는 해당 메서드를 고려하지 못함으로 compile error가 발생함 그래서 여기에서도 property에 `!`을 사용함

```js
class Person3 {
	name: string = 'asyn_test';
	// age: number; // error
  age!: number;

  async init() {
    this.age = 2
  }
}

const p3: Person3 = new Person3();
await p3.init();
```

<br>

### 정리

- 생성자 함수가 없으면, 디폴트 생성자가 불린다.
- 프로그래머가 만든 생성자가 하나라도 있으면, 디폴트 생성자는 사라진다. (즉, 우선적으로 contructor가 씌워진다.)
- strict 모드에서는 프로퍼티를 선언하는 곳 또는 생성자에서 값을 할당해야 함
- 프로퍼티 선언하는 곳 또는 생성자에서 값을 할당하지 않는 경우에는 !를 붙여 위험 표현
- 클래스의 프로퍼티가 정의 되어 있지만 값을 대입하지 않으면 undefined임
- 생성자에는 async를 설정할 수 없다.

<br>

> ## 접근 제어자 (access modifier : public, private, protected)

- TS는 아무 설정 없으면 class를 외부에서 모두 접근 가능함 (설정 안하면 default로 public인것임)
- `public`을 명시해도 상관 없음
- `private`로 해놓으면 밖에서 호출이 불가해짐 (private 키워드가 나오기 전에 암묵적으로 `_`를 붙여서 밖에서는 사용하지 마세요라고 모양을 통일해주었음)
- 그래서 private해 놓으면 언더바 '\_'를 붙여주는 습관이 남아 있음
