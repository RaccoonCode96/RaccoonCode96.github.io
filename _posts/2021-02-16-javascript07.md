---
title : "20210216_JavaScript07 Array_quizí™•ì¸, String methods, Array methods, JOSNê°œë…(HTTP, AJAX, XMLHttpRequest, JSON, XML), JSONí™œìš© " #ì œëª©
category : #ì¹´í…Œê³ ë¦¬
    - JavaScript
tag : #íƒœê·¸
    - JavaScript
    - Array methods
    - String methods
    - ë“œë¦¼ì½”ë”©byì—˜ë¦¬
    - Array quiz
    - JSON
    - HTTP
    - AJAX
    - XMLHttpRequest
    - XML
   
   
toc : true #ì˜†ì— ëª©ì°¨
---


># JavaScript07

- JavaScriptì— ëŒ€í•´ ê³µë¶€í•˜ê¸° ìœ„í•´ì„œ ìœ íŠœë¸Œ 'ë“œë¦¼ì½”ë”©byì—˜ë¦¬' JavaScript ê°•ì˜ë¥¼ ë“£ê³  ê¸€ì„ ì“°ê³  ìˆë‹¤.(ê°•ì˜ê°€ ì—„ì²­ ì˜ë˜ ìˆìœ¼ë‹ˆ ê°•ì˜ë¥¼ ì°¾ì•„ë³´ì!)
  - [ë“œë¦¼ì½”ë”©byì—˜ë¦¬ - JavaScript](https://www.youtube.com/watch?v=wcsVjmHrUQg&list=PLv2d7VI9OotTVOL4QmPfvJWPJvkmv6h-2)   

<br>
<br>


># ë“œë¦¼ì½”ë”© Array_quiz (ê°•ì˜ ë“£ê³ ì„œ í™•ì¸)

- ì¼ë‹¨, ê°•ì˜ ë“¤ìœ¼ë©´ì„œ ë†“ì¹œ Array API ìœ„ì¹˜ë¥¼ í™•ì¸í•¨
- **ê°€ë…ì„± ì¢‹ê²Œ ë©”ì†Œë“œë¥¼ ì—°ë‹¬ì•„ ì“¸ìˆ˜ ìˆëŠ” ë²•ì„ í™•ì¸í•¨(ë¦¬ì–¼ ê¿€íŒ)**

<br>

``` js
'use strict';

// Q1. make a string out of an array
console.log(' Q1. make a string out of an array')
{
const fruits = ['apple', 'banana', 'orange'];
console.log(fruits.toString()); // apple,banana,orange
console.log(fruits.join());
console.log(fruits.join('|'));
const k = false
console.log(typeof(k))
console.log(k.toString())
}




console.log('')
console.log('Q2. make an array out of a string')
// Q2. make an array out of a string
{
const fruits = 'ğŸ,ğŸ¥,ğŸŒ,ğŸ’'
console.log(fruits.split(','))
}




console.log('')
console.log('Q3. make this array look like this : [5, 4, 3, 2, 1]')
// Q3. make this array look like this : [5, 4, 3, 2, 1]
{
const array = [1, 2, 3, 4, 5];
console.log(array.reverse()); // reverse ì ‘ê·¼ë§Œ í•´ë„ ì˜í–¥ì„ ì¤Œ
console.log(array);
}




console.log('')
console.log('Q4. make new array without the first two elements (ë³€í˜•í•˜ë©´ ì•ˆë¨)')
// Q4. make new array without the first two elements (ë³€í˜•í•˜ë©´ ì•ˆë¨)
{
// ë³€í˜• í•˜ëŠ” ê²½ìš°
const array = [1, 2, 3, 4, 5];
array.splice(0, 2)
console.log(array)
const array1 = [1, 2, 3, 4, 5];
array1.shift();
array1.shift();
console.log(array1);
// ë³€í˜• ì•ˆí•˜ëŠ” ê²½ìš°
const array3 = [1, 2, 3, 4, 5];
console.log(array3.slice(2))
console.log(array3.slice(2, 5)) // sliceì—ì„œ end indexëŠ” ë°°ì œë¨
console.log(array3)
}

class Student {
    constructor(name, age, enrolled, score) {
        this.name = name;
        this.age = age;
        this.enrolled = enrolled;
        this.score = score;
    }
}
const students = [
    new Student('A', 29, true, 45),
    new Student('B', 28, false, 80),
    new Student('C', 30, true, 90),
    new Student('D', 40, false, 66),
    new Student('E', 18, true, 88),
    // new Student('F', 30, true, 90), // filter í™•ì¸ìš©
];





console.log('')
console.log('Q5. find a student with the score 90')
// Q5. find a student with the score 90
{ // ë‚´ê°€ í•œê±° // filter ì€ ëª¨ë‘ ì°¾ì•„ì„œ Array ë§Œë“¦
const scores = students.filter((Student) => Student.score === 90);
// console.log(scoreSt);
console.log(scores.pop());
}
{ // ê°•ì˜ì—ì„œ í•œê±° // findëŠ” ì²˜ìŒ ì°¾ì€ ê²ƒì„ return
const score90 = students.find((Student) => Student.score === 90);
console.log(score90);
}




console.log('')
console.log('Q6. make an array of enrolled students')
// Q6. make an array of enrolled students
{
const enrolled = students.filter((Student) => Student.enrolled == true);
console.log(enrolled);
// console.log(students); // ì›ë³¸ ì§€ì¥ ì—†ìŒ
}




console.log('')
console.log("Q7. make an array containing only the students' scores")
// Q7. make an array containing only the students' scores
// result should be : [45, 80, 90, 66, 88]
{
const scores = students.map((Student) => Student.score);
console.log(scores);
// console.log(students) // ì›ë³¸ ì§€ì¥ ì—†ìŒ
}




console.log('')
console.log("Q.8 check if there is a student with the score lower than 50")
// Q.8 check if there is a student with the score lower than 50
{ // ë‚´ê°€ í•œê±°
const check = students.some((Student) => Student.score < 50);
console.log(check);
}
{ // ê°•ì˜ì—ì„œ í•œê±° (andë¡œ or ì—°ì‚°í•˜ê³  ì‹¶ìœ¼ë©´ ì¡°ê±´ ë°˜ëŒ€ë¡œ í•˜ê³  ì¶œë ¥ê°’ë„ ë°˜ëŒ€ë¡œ)
const check = !students.every((Student) => Student.score >= 50);
console.log(check);
}




console.log('')
console.log("Q.9 compute students' average score")
// Q.9 compute students' average score
{ // ë‚´ê°€ í•œê±° (map, reduce) reduceëŠ” í”¼ë³´ë‚˜ì¹˜ ìˆ˜ì—´ì„
const scores = students.map((Student) => Student.score);
const average = scores.reduce((prev, curr) => {
    return (prev+curr)
}) / scores.length;
console.log(average);
}

{ // ë‚´ê°€í•œê±° (map , for of loop)
const scores = students.map((Student) => Student.score);
let sum = 0;
for (let score of scores) {
    sum += score; 
};
const average = sum / scores.length
console.log(average)
}

{ // ê°•ì˜ (reduce) // ì²«ë²ˆì§¸ ê°’ param ìœ„ì¹˜ ì¡°ì‹¬! reduce(func, initial)
const average = students.reduce((prev, curr) => {
    return (prev+curr.score)
}, 0) / (students.length)
console.log(average);
}





console.log('')
console.log('Q.10 make a string containing all the scores')
// Q.10 make a string containing all the scores
// result should be : '45, 80, 90, 66, 88'
{
const scores = students.map((Student) => Student.score);
console.log(scores.join())
}





// Bonus! do Q10 sorted in asending order
console.log('')
console.log('Bonus! do Q10 sorted in asending order')
// result should be : '45, 66, 80, 88, 90'

{ // ë‚´ê°€ í•œê±° // ê²°ê³¼ ìŒìˆ˜ aê°€ ì•ìœ¼ë¡œê° 
// sort ë§Œìœ¼ë¡œ
const scores = students.map((Student) => Student.score);
const sort_scores = scores.sort((a, b) => {
    return a - b;
}); 
console.log(sort_scores.join())
}

{ // sort, if ì´ìš©í•´ì„œ
const scores = students.map((Student) => Student.score);
const sort_scores = scores.sort((a, b) => {
    if (a < b) {
        return -1;
    } else if (a > b) {
        return +1;
    } else {
        return 0;
    }
}); 
console.log(sort_scores.join())
}

{// ê°•ì˜ (ì½”ë“œ ê°€ë…ì„± êµ³êµ³ ë¦¬ì–¼)
const result = students
    .map((student) => student.score)
    .sort((a, b) => a - b)
    .join();
console.log(result);
}
```


<br>
<br>
<br>



># ES String method

- ê°•ì˜ì—ì„œ ë³´ë‹ˆ ì •ì˜ëœ ìœ„ì¹˜ë¥¼ ì°¾ì•„ ê°ˆë•Œ ì–´ì œëŠ” symbolì„ ì°¾ì•„ ê°”ì—ˆë˜ ê²ƒì´ë‹¤.. ë‹¤ì‹œë³´ë‹ˆ ì„ íƒì§€ê°€ ë‘ê°€ì§€ê°€ ëœ¨ëŠ” ê²ƒì„ í™•ì¸í•˜ê³  ë‹¤ì‹œ `string method`ë¥¼ í™•ì¸í•˜ê³ ì í•œë‹¤.

<br>

- `toString(): string;` 
: Array ë•Œ ì²˜ëŸ¼ ë˜‘ê°™ì´ stringí˜•ìœ¼ë¡œ ë°”ê¾¸ì–´ì¤Œ (array, number, boolean ë“± -> string)
- `charAt(pos: number): string;`
: stringì—ì„œì˜ íŠ¹ì • indexë¥¼ paramë¡œ ë°›ì•„ í•´ë‹¹ indexì˜ characterë¥¼ ë°˜í™˜í•¨
- `charCodeAt(index: number): number;` 
: íŠ¹ì • indexë¥¼ ë°›ì•„ í•´ë‹¹ indexì˜ string characterì˜ ìœ ë‹ˆì½”ë“œ ê°’ì„ ë°˜í™˜í•¨ (í•´ë‹¹ ì¸ë±ìŠ¤ì— characterê°€ ì—†ìœ¼ë©´ NaNì„ ë°˜í™˜)  
- `concat(...strings: string[]): string;`
: í•´ë‹¹ string ëì— ë¶™ì¼ stringë“¤ì„ ë°›ì•„ í•©ì³ í•©ì¹œ ê²ƒì„ ë°˜í™˜í•¨
- `indexOf(searchString: string, position?: number): number;`
: Array ë•Œ ì²˜ëŸ¼ ì°¾ê³ ìí•˜ëŠ” string ê³¼ ì°¾ê¸° ì‹œì‘í•˜ëŠ” indexë¥¼ ë°›ì•„ ì‹œì‘í•˜ëŠ” indexë¡œ ë¶€í„° ì˜¤ë¥´ìª½ìœ¼ë¡œ ì²˜ìŒìœ¼ë¡œ ë°œê²¬í•œ ì¸ë±ìŠ¤ë¥¼ ë°˜í™˜
- `lastIndexOf(searchString: string, position?: number): number;`
: indesOfì™€ ê°™ì´ string ê³¼ ì°¾ê¸° ì‹œì‘í•˜ëŠ” indexë¥¼ ë°›ì•„ ì‹œì‘í•˜ëŠ” indexë¡œ ë¶€í„° ì™¼ìª½ìœ¼ë¡œ ì²˜ìŒìœ¼ë¡œ ë°œê²¬í•œ ì¸ë±ìŠ¤ë¥¼ ë°˜í™˜
- `localeCompare(that: string): number;`
: ë¡œì¼€ì¼ ìƒì˜ ë¬¸ìì—´ ì •ë ¬ ìˆœì„œì—ì„œ íŠ¹ì • stringì„ ë°›ì•„ ì›ë˜ì˜ stringê³¼ ë¹„êµí•˜ì—¬ ìˆœì„œë¥¼ ì•Œê²Œ ìˆ«ìë¥¼ ë°˜í™˜(ìŒìˆ˜:ì°¸ì¡°ë¬¸ì,ë¹„êµë¬¸ì ìˆœ / ì–‘ìˆ˜ : ë¹„êµë¬¸ì,ì°¸ì¡°ë¬¸ì ìˆœì„œ / 0 : ë‘˜ì´ ê°™ìŒ)
- `replace(searchValue: string | RegExp, replaceValue: string): string;`
: í•´ë‹¹ stringì—ì„œ ì°¾ëŠ” ë¬¸ìì™€ ëŒ€ì²´í•  ë¬¸ìë¥¼ paramìœ¼ë¡œ ë°›ì•„ ëŒ€ì²´í•¨
- `replace(searchValue: string | RegExp, replacer: (substring: string, ...args: any[]) => string): string;`
: í•´ë‹¹ stringì—ì„œ ì°¾ëŠ” ë¬¸ìì— ëŒ€ì²´í•  ë¬¸ìë¡œ replacerë¼ëŠ” í•¨ìˆ˜ë¡œ í•´ë‹¹ stringì„ ë°›ì•„ í™œìš©í•´ returnì‹œí‚¨ stringìœ¼ë¡œ ëŒ€ì²´í•˜ê²Œ í• ìˆ˜ ìˆë‹¤.
- `slice(start?: number, end?: number): string;`
: í•´ë‹¹ stringì˜ ë¶€ë¶„ì„ ë°˜í™˜ (start index ì´ìƒ end index ë¯¸ë§Œ ê¹Œì§€ ì¶”ì¶œ, end ì—†ìœ¼ë©´ ë§ˆì§€ë§‰ indexë¡œ ë“¤ì–´ê°) **í•­ìƒ start index < end index í•´ì•¼ í•¨ ë§Œì•½ ì»¤ë²„ë¦¬ë©´ ""ë¥¼ ë°˜í™˜, ìŒìˆ˜ ê°’ë„ ìŒìˆ˜ ì¸ë±ìŠ¤ë¡œ ì²˜ë¦¬í•´ì„œ ì¸ì‹**
- `split(separator: string | RegExp, limit?: number): string[];`
: separatorë¡œ íŠ¹ì • ë¬¸ìë¥¼ ë°›ì•„ì„œ separator ë¬¸ìë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì˜ë¼ì„œ ë°°ì—´ì˜ ì›ì†Œë¡œ ë§Œë“¤ì–´ ë°°ì—´ì„ ë§Œë“¤ìŒ limitì€ ë°°ì—´ë¡œ ë“¤ì–´ê°ˆ ì›ì†Œì˜ ê°œìˆ˜ ì œí•œì„
- `substring(start: number, end?: number): string;`
: sliceì™€ ë˜‘ê°™ìœ¼ë‚˜ **start index > end index ì—¬ë„ ì•Œì•„ì„œ í°ìˆ«ìë¥¼ endë¡œ ì‘ì€ ìˆ«ìë¥¼ startë¡œ ì¸ì‹í•¨, ìŒìˆ˜ ì¸ë±ìŠ¤ëŠ” ë¬´ì¡°ê±´ 0ì¸ë±ìŠ¤ë¡œ ì¸ì‹**
- `toLowerCase(): string;`
: ì†Œë¬¸ìë¡œ ëª¨ë‘ ë³€ê²½
- `toUpperCase(): string;`
: ëŒ€ë¬¸ìë¡œ ëª¨ë‘ ë³€ê²½
- `toLocaleLowerCase(locales?: string | string[]): string;`
: í˜¸ìŠ¤íŠ¸ì˜ í˜„ì¬ ì§€ì •í•˜ê³ ì í•˜ëŠ” ë¡œì¼€ì¼ ì˜µì…˜ì„ ë°›ì•„ ì†Œë¬¸ìë¡œ ë³€ê²½í•˜ê³  ë¡œì¼€ì¼ ê°’ì„ ê°™ì´ ê°€ì§€ê³  ìˆìŒ
- `toLocaleUpperCase(locales?: string | string[]): string;`
: ìœ„ì™€ ê°™ì€ë° ëŒ€ë¬¸ìë¡œ ë³€ê²½
- `trim(): string;`
: í•´ë‹¹ stringì—ì„œì˜ ë¹ˆê³µë°±, ì¢…ê²°ê¸°í˜¸ ë“±ì„ ì œê±°í•¨ (ë°ì´í„° ì •ì œì‹œ ì¢‹ë‹¤.)

<br>
<br>
<br>


``` js
interface String {
    /** Returns a string representation of a string. */
    toString(): string;

    /**
     * Returns the character at the specified index.
     * @param pos The zero-based index of the desired character.
     */
    charAt(pos: number): string;

    /**
     * Returns the Unicode value of the character at the specified location.
     * @param index The zero-based index of the desired character. If there is no character at the specified index, NaN is returned.
     */
    charCodeAt(index: number): number;

    /**
     * Returns a string that contains the concatenation of two or more strings.
     * @param strings The strings to append to the end of the string.
     */
    concat(...strings: string[]): string;

    /**
     * Returns the position of the first occurrence of a substring.
     * @param searchString The substring to search for in the string
     * @param position The index at which to begin searching the String object. If omitted, search starts at the beginning of the string.
     */
    indexOf(searchString: string, position?: number): number;

    /**
     * Returns the last occurrence of a substring in the string.
     * @param searchString The substring to search for.
     * @param position The index at which to begin searching. If omitted, the search begins at the end of the string.
     */
    lastIndexOf(searchString: string, position?: number): number;

    /**
     * Determines whether two strings are equivalent in the current locale.
     * @param that String to compare to target string
     */
    localeCompare(that: string): number;

    /**
     * Matches a string with a regular expression, and returns an array containing the results of that search.
     * @param regexp A variable name or string literal containing the regular expression pattern and flags.
     */
    match(regexp: string | RegExp): RegExpMatchArray | null;

    /**
     * Replaces text in a string, using a regular expression or search string.
     * @param searchValue A string to search for.
     * @param replaceValue A string containing the text to replace for every successful match of searchValue in this string.
     */
    replace(searchValue: string | RegExp, replaceValue: string): string;

    /**
     * Replaces text in a string, using a regular expression or search string.
     * @param searchValue A string to search for.
     * @param replacer A function that returns the replacement text.
     */
    replace(searchValue: string | RegExp, replacer: (substring: string, ...args: any[]) => string): string;

    /**
     * Finds the first substring match in a regular expression search.
     * @param regexp The regular expression pattern and applicable flags.
     */
    search(regexp: string | RegExp): number;

    /**
     * Returns a section of a string.
     * @param start The index to the beginning of the specified portion of stringObj.
     * @param end The index to the end of the specified portion of stringObj. The substring includes the characters up to, but not including, the character indicated by end.
     * If this value is not specified, the substring continues to the end of stringObj.
     */
    slice(start?: number, end?: number): string;

    /**
     * Split a string into substrings using the specified separator and return them as an array.
     * @param separator A string that identifies character or characters to use in separating the string. If omitted, a single-element array containing the entire string is returned.
     * @param limit A value used to limit the number of elements returned in the array.
     */
    split(separator: string | RegExp, limit?: number): string[];

    /**
     * Returns the substring at the specified location within a String object.
     * @param start The zero-based index number indicating the beginning of the substring.
     * @param end Zero-based index number indicating the end of the substring. The substring includes the characters up to, but not including, the character indicated by end.
     * If end is omitted, the characters from start through the end of the original string are returned.
     */
    substring(start: number, end?: number): string;

    /** Converts all the alphabetic characters in a string to lowercase. */
    toLowerCase(): string;

    /** Converts all alphabetic characters to lowercase, taking into account the host environment's current locale. */
    toLocaleLowerCase(locales?: string | string[]): string;

    /** Converts all the alphabetic characters in a string to uppercase. */
    toUpperCase(): string;

    /** Returns a string where all alphabetic characters have been converted to uppercase, taking into account the host environment's current locale. */
    toLocaleUpperCase(locales?: string | string[]): string;

    /** Removes the leading and trailing white space and line terminator characters from a string. */
    trim(): string;

    /** Returns the length of a String object. */
    readonly length: number;

    // IE extensions
    /**
     * Gets a substring beginning at the specified location and having the specified length.
     * @param from The starting position of the desired substring. The index of the first character in the string is zero.
     * @param length The number of characters to include in the returned substring.
     */
    substr(from: number, length?: number): string;

    /** Returns the primitive value of the specified object. */
    valueOf(): string;

    readonly [index: number]: string;
}
```

<br>
<br>
<br>


># ì „ê¸€ì—ì„œ ë†“ì³¤ë˜ Array API

- `find`,`(predicate: (value: T, index: number, obj: T[]) => unknown, thisArg?: any): T | undefined;`
: í•´ë‹¹ Arrayì˜ value, index, objë¥¼ í™œìš©í•˜ëŠ” predicate í•¨ìˆ˜ ì¡°ê±´ì— ë°°ì—´ì˜ ì›ì†Œê°€ ì²˜ìŒìœ¼ë¡œ true ê°’ì„ ê°€ì§€ëŠ” ê²½ìš° ê·¸ ì›ì†Œì˜ ê°’ì„ ë°˜í™˜(ì¦‰, ì°¾ì•„ì„œ ì²˜ìŒ ê°’), ì—†ìœ¼ë©´ undifined ë°˜í™˜ (thisArgëŠ” í•¨ìˆ˜ì—ì„œ ì‚¬ìš©í•  thisë¡œ ì‚¬ìš©í•  ê°ì²´)
- `findIndex`, `(predicate: (value: T, index: number, obj: T[]) => unknown, thisArg?: any): number;`
: findì²˜ëŸ¼ ì“°ì´ëŠ”ë° ì°¾ì€ ì²«ë²ˆì§¸ ì›ì†Œì˜ indexê°’ ë°˜í™˜
- `fill`,`(value: T, start?: number, end?: number): this;`
: start index ì´ìƒ end index ë¯¸ë§Œ ê¹Œì§€ valueë¡œ ë°”ê¿” ì±„ì›€(ìŒìˆ˜ ì¸ë±ìŠ¤ ì¸ì‹í•¨)
- `copyWithin`, `(target: number, start: number, end?: number): this;`
: start index ì´ìƒ end index ë¯¸ë§Œ ê¹Œì§€ì˜ ì›ì†Œë¥¼ ë³µì‚¬í•˜ì—¬ target indexë¶€í„° ì°¨ë¡€ëŒ€ë¡œ ë®ì–´ì”€

``` js
interface Array<T> {
    /**
     * Returns the value of the first element in the array where predicate is true, and undefined
     * otherwise.
     * @param predicate find calls predicate once for each element of the array, in ascending
     * order, until it finds one where predicate returns true. If such an element is found, find
     * immediately returns that element value. Otherwise, find returns undefined.
     * @param thisArg If provided, it will be used as the this value for each invocation of
     * predicate. If it is not provided, undefined is used instead.
     */
    find<S extends T>(predicate: (this: void, value: T, index: number, obj: T[]) => value is S, thisArg?: any): S | undefined;
    find(predicate: (value: T, index: number, obj: T[]) => unknown, thisArg?: any): T | undefined;

    /**
     * Returns the index of the first element in the array where predicate is true, and -1
     * otherwise.
     * @param predicate find calls predicate once for each element of the array, in ascending
     * order, until it finds one where predicate returns true. If such an element is found,
     * findIndex immediately returns that element index. Otherwise, findIndex returns -1.
     * @param thisArg If provided, it will be used as the this value for each invocation of
     * predicate. If it is not provided, undefined is used instead.
     */
    findIndex(predicate: (value: T, index: number, obj: T[]) => unknown, thisArg?: any): number;

    /**
     * Returns the this object after filling the section identified by start and end with value
     * @param value value to fill array section with
     * @param start index to start filling the array at. If start is negative, it is treated as
     * length+start where length is the length of the array.
     * @param end index to stop filling the array at. If end is negative, it is treated as
     * length+end.
     */
    fill(value: T, start?: number, end?: number): this;

    /**
     * Returns the this object after copying a section of the array identified by start and end
     * to the same array starting at position target
     * @param target If target is negative, it is treated as length+target where length is the
     * length of the array.
     * @param start If start is negative, it is treated as length+start. If end is negative, it
     * is treated as length+end.
     * @param end If not specified, length of the this object is used as its default value.
     */
    copyWithin(target: number, start: number, end?: number): this;
}
```

<br>
<br>
<br>


># JavaScript - JSON

- HTTP : client(request) <-> server(response) ë¼ë¦¬ í†µì‹ í•˜ëŠ” ë²•ìœ¼ë¡œ protocal ì¤‘ì˜ í•˜ë‚˜ (Hypertext Transfer Protocal)
  - Hyptertext : webì—ì„œì˜ link, resource, docs, image, file ë“±

- í†µì‹  ë°©ë²• 2ê°€ì§€
  - fetch API
  - XHR((XMLHttpRequest) ê°ì²´ë¥¼ ì‚¬ìš©í•˜ëŠ” ë°©ë²•

- AJAX : HTTPë¥¼ ì´ìš©í•œ ë¬¸ì„œë“¤ì„ ë°›ì•„ì˜¤ëŠ” ë°©ë²•ìœ¼ë¡œ web pageì—ì„œ ë™ì ìœ¼ë¡œ ì„œë²„ì—ê²Œ XHR ê°ì²´ í˜•íƒœë¡œ ë°ì´í„°ë¥¼ ì£¼ê³  ë°›ì„ ìˆ˜ ìˆëŠ” ê¸°ìˆ  (Asynchronous JavaScript And XML) 
  - XHR (XMLHttpRequest) : ë¸Œë¼ìš°ì € APIì—ì„œ ì œê³µí•˜ëŠ” ì˜¤ë¸Œì íŠ¸ë¡œ ê°„ë‹¨íˆ ë°ì´í„°ë¥¼ ì„œë²„ì— ìš”ì²­í•˜ê³  ë°›ì•„ ì˜¬ìˆ˜ ìˆìŒ ! XML ë§Œ ì£¼ê³  ë°›ëŠ”ê²Œ ì•„ë‹˜(JSON, XML, HTML ê·¸ë¦¬ê³  ì¼ë°˜ í…ìŠ¤íŠ¸ í˜•ì‹ ë“±ì„ í¬í•¨í•œ ë‹¤ì–‘í•œ í¬ë§·) !
      
- XML : HTMLì²˜ëŸ¼ markup ì–¸ì–´ì¤‘ì— í•˜ë‚˜ë¡œ ê³¼ê±°ì— ì£¼ë¡œ ì‚¬ìš© (ë¶ˆí•„ìš”í•œ íƒœê·¸ê°€ ë§ì•„, ê°€ë…ì„± ë–¨ì–´ì§) 
- JSON (JavaScript Object Notation): Object {key : value} ì´ëŸ° í˜•ì‹ì˜ ë°ì´í„° í¬ë§·
  - ë¸Œë¼ìš°ì € ë˜ëŠ” ëª¨ë°”ì¼ì—ì„œ ì„œë²„ì™€ ë°ì´í„°ë¥¼ ì£¼ê³  ë°›ì„ ê²½ìš° ì‚¬ìš©
  - ì„œë²„ í†µì‹  í•˜ì§€ ì•Šì„ ê²½ìš° ì˜¤ë¸Œì íŠ¸ë¥¼ file ì‹œìŠ¤í…œì— ì €ì¥ì‹œì—ë„ ì‚¬ìš©ë¨
  - simple data interchange format
  - lightweight text-based structure
  - easy to read
  - key-value pairs
  - used for serialization and transmission of data between the network the network connection (ë°ì´í„° ì§ë ¬í™” ë° ì „ì†¡ì‹œ ì“°ì„)
  - independent programming language and platform (í”„ë¡œê·¸ë¨ ì–¸ì–´ì— ìƒê´€ ì—†ì´ ê°™ì´ ì‚¬ìš©ê°€ëŠ¥)

<br>
<br>
<br>

>## JSON ê³µë¶€ ë°©ë²•

- objectë¥¼ ì–´ë–»ê²Œ serialize í•˜ì—¬ json(string)ìœ¼ë¡œ ë³€í™˜ í• ì§€
- ë°˜ëŒ€ë¡œ jsonì„ deserialize í•˜ì—¬ objectë¡œ ë³€í™˜ í• ì§€

``` js
interface JSON {
    /**
     * Converts a JavaScript Object Notation (JSON) string into an object.
     * @param text A valid JSON string.
     * @param reviver A function that transforms the results. This function is called for each member of the object.
     * If a member contains nested objects, the nested objects are transformed before the parent object is.
     */
    parse(text: string, reviver?: (this: any, key: string, value: any) => any): any;
    /**
     * Converts a JavaScript value to a JavaScript Object Notation (JSON) string.
     * @param value A JavaScript value, usually an object or array, to be converted.
     * @param replacer A function that transforms the results.
     * @param space Adds indentation, white space, and line break characters to the return-value JSON text to make it easier to read.
     */
    stringify(value: any, replacer?: (this: any, key: string, value: any) => any, space?: string | number): string;
    /**
     * Converts a JavaScript value to a JavaScript Object Notation (JSON) string.
     * @param value A JavaScript value, usually an object or array, to be converted.
     * @param replacer An array of strings and numbers that acts as an approved list for selecting the object properties that will be stringified.
     * @param space Adds indentation, white space, and line break characters to the return-value JSON text to make it easier to read.
     */
    stringify(value: any, replacer?: (number | string)[] | null, space?: string | number): string;
}
```

<br>
<br>
<br>


>## JSON ê´€ë ¨ ì‚¬ì´íŠ¸

- **JSON Diff**
  - ì„œë²„ì—ì„œ ë°›ì•„ì˜¨ ìë£Œê°€ ì²«ë²ˆì§¸ì™€ ë‘ë²ˆì§¸ ìë£Œê°€ ì–´ë–»ê²Œ ë‹¤ë¥¸ì§€ ëª¨ë¥¼ë•Œ ë¹„êµ ê°€ëŠ¥
  - ë¬¸ì œ debuging ì‹œì— ì‚¬ìš© ê°€ëŠ¥

- **JSON Beautifier**
  - ì„œë²„ì—ì„œ ë°›ì•„ì˜¨ JSON í¬ë©§ì´ ë§ê°€ì§€ëŠ” ê²½ìš°(ì½”ë“œë¥¼ ê·¸ëƒ¥ ì¤„ê¸€ë¡œ ê°€ì ¸ì™€ ì§„ê²½ìš°) -> í¬ë§· í˜•íƒœë¡œ ë§Œë“¤ì–´ì¤Œ

- **JSON Parser** 
  - jsonì„ objectí˜•íƒœë¡œ í™•ì¸ í•˜ê³  ì‹¶ë‹¤ë©´ ì‚¬ìš©(ëˆˆìœ¼ë¡œ ì‰½ê²Œ í™•ì¸ ê°€ëŠ¥)

- **JSON Validator**
  - JSON syntax í™•ì¸ ê°€ëŠ¥

